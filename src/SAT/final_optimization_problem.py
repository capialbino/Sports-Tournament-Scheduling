from z3 import *


def create_round_robin_schedule(N):
    """
    Schedule a Round Robin tournament for N teams using 

    Constraints:
    1. Every team plays every other team exactly once.
    2. Every team plays exactly once per week.
    3. No team plays more than twice in the same period (time slot).
    """

    # Verify N is even
    assert N % 2 == 0, "Number of teams must be even"

    # Parameters
    num_weeks = N - 1
    num_periods = N // 2
    num_matches = (N - 1) * (N // 2)

    # Generate matches using circle method
    def generate_matches():
        """Generate all matches using the circle method"""
        matches = []
        for w in range(num_weeks):
            for p in range(num_periods):
                if p == 0:
                    # First period logic
                    home = N - 1 if w % 2 == 0 else w
                    away = w if w % 2 == 0 else N - 1
                else:
                    # Other periods
                    home = (p + w) % (N - 1)
                    away = (N - p + w - 1) % (N - 1)
                matches.append((home, away))
        return matches

    matches = generate_matches()
    print(matches)
    # Decision Variables: matches_idx[p][w] = match ID for period p in week w
    matches_idx = [[Int(f'match_p{p}_w{w}') for w in range(num_weeks)]
                   for p in range(num_periods)]

    # Create solver
    s = Solver()

    # Domain constraints: each match_idx must be a valid match ID
    for p in range(num_periods):
        for w in range(num_weeks):
            s.add(matches_idx[p][w] >= 0)
            s.add(matches_idx[p][w] < num_matches)

    # CONSTRAINT 1: Break week symmetry - first match of first week is the first generated by RR
    s.add(matches_idx[0][0] == 0)

    # CONSTRAINT 2: Solution based on round robin generation
    # Each week w can only use matches from index w*(N/2) to (w+1)*(N/2)-1
    for w in range(num_weeks):
        for p in range(num_periods):
            s.add(matches_idx[p][w] >= w * num_periods)
            s.add(matches_idx[p][w] < (w + 1) * num_periods)

    # CONSTRAINT 3: All different - each match used exactly once
    all_matches = [matches_idx[p][w] for p in range(num_periods) for w in range(num_weeks)]
    s.add(Distinct(all_matches))

    # CONSTRAINT 4: Each team plays at most twice in any period
    # for p in range(num_periods):
    #     # Get all matches in this period across all weeks
    #     period_matches = [matches_idx[p][w] for w in range(num_weeks)]
    #
    #     # For each team, count how many times it appears in this period
    #     for team in range(N):
    #         team_count = Sum([
    #             If(Or(
    #                 matches[period_matches[w]][0] == team,
    #                 matches[period_matches[w]][1] == team
    #             ), 1, 0)
    #             for w in range(num_weeks)
    #         ])
    #         s.add(team_count <= 2)

    # Note: The "literal" conversion in the If statement above doesn't work directly
    # We need to create the constraint differently for Z3

    # CONSTRAINT 4 (corrected): Count team appearances per period
    for p in range(num_periods):
        for team in range(N):
            # Count occurrences of this team in period p across all weeks
            count_constraints = []
            for w in range(num_weeks):
                # For each possible match in week w at period p
                for m_id in range(w * num_periods, (w + 1) * num_periods):
                    home, away = matches[m_id]
                    # If this match is selected and contains the team
                    if home == team or away == team:
                        count_constraints.append(matches_idx[p][w] == m_id)

            # At most 2 of these can be true
            if count_constraints:
                s.add(PbLe([(c, 1) for c in count_constraints], 2))

    # Solve
    if s.check() == sat:
        model = s.model()

        # Extract solution
        schedule = [[model.evaluate(matches_idx[p][w]).as_long()
                     for w in range(num_weeks)]
                    for p in range(num_periods)]

        # Print solution
        print(f"Round Robin Schedule for {N} teams:\n")
        for w in range(num_weeks):
            print(f"Week {w + 1}:\n")
            print("  ", end="")
            for p in range(num_periods):
                print(f"Period {p + 1}\t", end="")
            print("\n    ", end="")

            for p in range(num_periods):
                match_id = schedule[p][w]
                home, away = matches[match_id]
                print(f"{home} vs {away}\t", end="")
            print("\n")

        return schedule
    else:
        print("No solution found!")
        return None


# Example usage
if __name__ == "__main__":
    import time
    N = 6  # Number of teams (must be even)
    start = time.time()
    schedule = create_round_robin_schedule(N)
    end = time.time()
    print(end - start)